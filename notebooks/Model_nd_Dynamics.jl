import Pkg
Pkg.activate(@__DIR__)

using LinearAlgebra
using Test

include("Quaternion.jl")

"""
    Model

A mutable struct that holds the physical parameters of a quadrotor model.

# Fields
- `g::Float64`: Acceleration due to gravity (m/s²).
- `m::Float64`: Mass of the quadrotor (kg).
- `ℓ::Float64`: Distance from the center of the quadrotor to each propeller (m).
- `J::Matrix{Float64}`: 3x3 inertia moment matrix of the quadrotor (kg⋅m²).
- `R::Float64`: Radius of each propeller (m).
- `prop_min_h::Float64`: Minimum height above ground for propeller ground effect (m).
- `ρ::Float64`: Ground effect correction factor (dimensionless).
- `umin::Vector{Float64}`: Vector of minimum thrust for each of the 4 motors (N).
- `umax::Vector{Float64}`: Vector of maximum thrust for each of the 4 motors (N).
- `kt::Float64`: Thrust coefficient of the propellers (N/rpm² or N/rad²s⁻²).
- `km::Float64`: Moment coefficient of the propellers (N⋅m/rpm² or N⋅m/rad²s⁻²).
- `Nx::Int32`: Size of the full state vector.
- `Nu::Int32`: Dimension of the full control input vector.
"""
mutable struct Model
    g::Float64 # gravity
    m::Float64 # mass
    ℓ::Float64 # inter-propeller distance
    J::Matrix{Float64} # inertia momment matrix
    R::Float64 # propeller radius
    prop_min_h::Float64 # TODO
    ρ::Float64 # GE correction factor (https://doi.org/10.1109/ChiCC.2015.7260521)
    umin::Vector{Float64} # Thrust inferior limit
    umax::Vector{Float64} # Thrust superior limit

    kt::Float64 # Thrust Coefficient
    km::Float64 # Moment Coefficient

    Nx::Int32 # Full state vector size
    Nu::Int32 # Full control dimension
end

"""
    ground_effect(height, prop_radius::Float64, adjust_factor::Float64, height_saturation::Float64)

Calculates the ground effect factor on the thrust generated by the propellers.

This function models the increase in thrust efficiency when the quadrotor is close to the ground.

# Arguments
- `height`: Current height of the quadrotor above the ground (m).
- `prop_radius::Float64`: Radius of the propeller (m).
- `adjust_factor::Float64`: Ground effect correction factor (ρ from the Model struct).
- `height_saturation::Float64`: Minimum height below which ground effect is saturated (prop_min_h from the Model struct).

# Returns
- `Float64`: The ground effect amplification factor (>= 1).
"""
function ground_effect(
        height, 
        prop_radius::Float64, 
        adjust_factor::Float64, 
        height_saturation::Float64
    )
    saturated_height = max(height, height_saturation)
    return (1/(1 - adjust_factor*(prop_radius/(4*saturated_height))^2))
end

"""
    quad_dynamics(model::Model, x, u, plat_h::Float64)

Computes the time derivative of the quadrotor's state vector based on the applied control inputs.

This function implements the nonlinear equations of motion for a quadrotor, including the effects of gravity and ground effect.

# Arguments
- `model::Model`: The `Model` struct containing the quadrotor's physical parameters.
- `x`: The current state vector of the quadrotor: `[r; q; v; ω]`, where
    - `r`: 3D position in the inertial frame (m).
    - `q`: Unit quaternion representing the orientation.
    - `v`: 3D linear velocity in the body frame (m/s).
    - `ω`: 3D angular velocity in the body frame (rad/s).
- `u`: The control input vector, typically the thrust of each of the 4 motors (N).
- `plat_h::Float64`: Height of the platform or ground level (m), used for ground effect calculation.

# Returns
- `Vector{Float64}`: The time derivative of the state vector `dx = [dr; dq; dv; dω]`.
"""
function quad_dynamics(
        model::Model,
        x,
        u,
        plat_h::Float64
    )
    local r = x[1:3]
    local q = x[4:7] / norm(x[4:7]) # Ensure q is a unit quaternion
    local v = x[8:10] # Defined at the body frame
    local ω = x[11:13] # Angular velocity
    
    local Q = qtoQ(q) # Compute the Rotation Matrix

    local m = model.m
    local g = model.g
    local J = model.J
    local kt = model.kt
    local km = model.km
    local ℓ = model.ℓ

    quatm = QuaternionMatrices()
    H = quatm.H
    
    dr = Q * v
    dq = 0.5 * L(q)*H*ω

    local kge = ground_effect(x[2] - plat_h, model.R, model.ρ, model.prop_min_h)
    
    dv = Q'*[0; 0; -g] + (1/m)*[zeros(2,4); kge*ones(1,4)]*u - hat(ω)*v
    
    dω = J\(-hat(ω)*J*ω + [0 ℓ 0 -ℓ; -ℓ 0 ℓ 0; km/kt -km/kt km/kt -km/kt]*u)
    
    return [dr; dq; dv; dω]
end

"""
    infinity_norm_of_difference(x::Vector{Float64}, x_ref::Vector{Float64})

Calculates the infinity norm of the difference between two state vectors, handling quaternion normalization.

This function computes the maximum absolute difference between corresponding elements of two state vectors. It also ensures that the quaternions in both state vectors are in the same hemisphere to avoid issues with the double cover of SO(3).

# Arguments
- `x::Vector{Float64}`: The first state vector.
- `x_ref::Vector{Float64}`: The reference state vector. Both vectors are assumed to be in the format `[r; q; v; ω]`.

# Returns
- `Float64`: The infinity norm of the difference between the two state vectors.
"""
function infinity_norm_of_difference(x::Vector{Float64}, x_ref::Vector{Float64})
    q = x[4:7]
    q_ref = x_ref[4:7]
    
    # Ensure that q and q_ref are in the same hemisphere
    # Avoid "windup" phenomenon caused by 4pi periodicity
    if(q'*q_ref < 0)
        q .= -q
    end
    
    delta_phi = qtorp(L(q_ref)'*q)
    
    return maximum(abs, [x[1:3] - x_ref[1:3]; delta_phi; x[8:13] - x_ref[8:13]])
end

"""
    find_hover_conditions(model::Model, height::Float64)

Calculates the hover state and the required control input (thrust) for a given height.

This function determines the state vector (position, orientation, velocities) and the collective thrust needed for the quadrotor to maintain a stable hover at a specified height.

# Arguments
- `model::Model`: The `Model` struct containing the quadrotor's physical parameters.
- `height::Float64`: The desired hover height above the ground (m).

# Returns
- `Tuple{Vector{Float64}, Vector{Float64}}`: A tuple containing:
    - `x_hover::Vector{Float64}`: The hover state vector `[r; q; v; ω]`.
    - `u_hover::Vector{Float64}`: The control input vector (collective thrust for each motor) required for hover.
"""
function find_hover_conditions(model::Model, height::Float64)
    @test height >= model.prop_min_h
    
    local r = [0.0; 0; max(height, model.prop_min_h)]
    local q = [1.0; 0; 0; 0]
    local v = zeros(3)
    local ω = zeros(3)
    x_hover = [r; q; v; ω];

    local weight = model.m * model. g
    
    local kge = ground_effect(height, model.R, model.ρ, model.prop_min_h)
    
    u_hover = (weight/(4))*ones(4)
    
    return x_hover, u_hover
end

"""
    reduce_x_state(x_full::Vector{Float64})

Reduces the full state vector by replacing the quaternion with its Rodriguez parameters.

This function takes the full 13-element state vector and returns a reduced 12-element state vector where the 4-element quaternion is replaced by the 3-element Rodriguez parameter representation of the orientation.

# Arguments
- `x_full::Vector{Float64}`: The full state vector `[r; q; v; ω]`.

# Returns
- `Vector{Float64}`: The reduced state vector `[r; q_rp; v; ω]`, where `q_rp` are the Rodriguez parameters.
"""
function reduce_x_state(x_full::Vector{Float64})
    return [x_full[1:3]; qtorp(x_full[4:7]); x_full[8:13]]
end