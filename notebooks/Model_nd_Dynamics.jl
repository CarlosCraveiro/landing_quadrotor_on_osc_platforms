import Pkg
Pkg.activate(@__DIR__)

using LinearAlgebra
using Test

include("Quaternion.jl")

"""
Describes the data structure representing the planar quadrotor model and its physical properties, with units specified according to the International System of Units (SI).

**Business Rules (with SI Units):**

* **Gravity (`g`):** Acceleration due to gravity, measured in meters per second squared (m/s^2), a constant positive value.
* **Mass (`m`):** Total mass of the quadrotor, measured in kilograms (kg), a positive value.
* **Inter-Propeller Distance (`ℓ`):** The distance between the centers of the two propellers, measured in meters (m).
* **Inertia Moment (`J`):** The moment of inertia of the quadrotor about its center of mass, measured in kilogram-meters squared (kg * m^2), relevant for rotational motion.
* **Propeller Radius (`R`):** The radius of each propeller, measured in meters (m), used in the ground effect calculation.
* **Propeller Minimum Height (`prop_min_h`):** Represents a threshold or saturation height for the ground effect model, measured in meters (m). The ground effect calculation might be capped or behave differently below this height. **(TODO: Needs further clarification on its specific role in the ground effect model).**
* **Air Density (`ρ`):** Air density, measured in kilograms per cubic meter (kg/m^3), used as a correction factor in the ground effect model, likely based on the provided DOI.
* **Minimum Thrust (`umin`):** A vector defining the lower limits for each rotor's thrust, measured in Newtons (N). Expected to have two elements.
* **Maximum Thrust (`umax`):** A vector defining the upper limits for each rotor's thrust, measured in Newtons (N). Expected to have two elements.
"""
mutable struct Model
    g::Float64 # gravity
    m::Float64 # mass
    ℓ::Float64 # inter-propeller distance
    J::Matrix{Float64} # inertia momment matrix
    R::Float64 # propeller radius
    prop_min_h::Float64 # TODO
    ρ::Float64 # GE correction factor (https://doi.org/10.1109/ChiCC.2015.7260521)
    umin::Vector{Float64} # Thrust inferior limit
    umax::Vector{Float64} # Thrust superior limit

    kt::Float64 # Thrust Coefficient
    km::Float64 # Moment Coefficient
end

"""
    Calculates the ground effect factor based on height, propeller radius, adjustment factor, and a minimum height saturation. The ground effect increases as the aircraft gets closer to the ground.

**Business Rules:**

* **Height Saturation:** The effective height used in the calculation is capped at `height_saturation`; the actual `height` will be used if it's greater than `height_saturation`. This prevents unrealistic ground effect calculations at very low altitudes.
* **Ground Effect Increase:** The returned factor is always greater than or equal to 1 and increases as the saturated height decreases relative to the propeller radius.
* **Adjustment Factor:** The `adjust_factor` scales the intensity of the ground effect.
"""
function ground_effect(height, prop_radius, adjust_factor, height_saturation)
    saturated_height = max(height, height_saturation)
    return (1/(1 - adjust_factor*(prop_radius/(4*saturated_height))^2))
end

# Planar Quadrotor Dynamics for modeling
"""
(DEPRECATED, Change the state vector (x) to update...)
Computes the planar quadrotor's dynamics, considering ground effect. It calculates the state derivatives (linear and angular accelerations) based on the current state, control inputs (rotor thrusts), and platform height.

**Business Rules:**

* **Planar Motion:** The model assumes motion in the vertical plane (x and y) and considers the roll angle (θ) as the only rotational degree of freedom.
* **Control Inputs:** `u[1]` and `u[2]` represent the thrust generated by the two rotors.
* **Ground Effect:** The `ground_effect` function (using the relative height to the platform) modifies the thrust forces.
* **Forces:** The linear accelerations (ẍ, ÿ) are determined by the thrust components along the body axes, the ground effect factor, and gravity.
* **Torque:** The angular acceleration (ô) is generated by the differential thrust of the two rotors, acting at a distance from the center of mass.
* **State Vector:** The input state `x` is expected to be `[x, y, θ, ẋ, ẏ, θ̇]`.
* **Model Parameters:** The function relies on parameters within the `model` struct, including mass (`m`), gravitational acceleration (`g`), moment of inertia (`J`), arm length (`ℓ`), propeller radius (`R`), air density (`ρ`), and minimum propeller height for ground effect (`prop_min_h`).
* **Platform Height:** `plat_h` represents the height of the ground platform, used to calculate the relative height for the ground effect model.
"""
function quad_dynamics(model, x, u, plat_h)
    local r = x[1:3]
    local q = x[4:7] / norm(x[4:7]) # Ensure q is a unit quaternion
    local v = x[8:10] # Defined at the body frame
    local ω = x[11:13] # Angular velocity
    
    local Q = qtoQ(q) # Compute the Rotation Matrix

    local m = model.m
    local g = model.g
    local J = model.J
    local kt = model.kt
    local km = model.km
    local ℓ = model.ℓ

    quatm = QuaternionMatrices()
    H = quatm.H
    
    dr = Q * v
    dq = 0.5 * L(q)*H*ω

    local kge = kt * ground_effect(x[2] - plat_h, model.R, model.ρ, model.prop_min_h)
    
    dv = Q'*[0; 0; -g] + (1/m)*[zeros(2,4); kge*ones(1,4)]*u - hat(ω)*v
    
    dω = J\(-hat(ω)*J*ω + [0 ℓ*kt 0 -ℓ*kt; -ℓ*kt 0 ℓ*kt 0; km -km km -km]*u)
    
    return [dr; dq; dv; dω]
end

"""
    Infinity Norm
"""
function infinity_norm_of_difference(x, x_ref)
    q = x[4:7]
    q_ref = x_ref[4:7]
    
    # Ensure that q and q_ref are in the same hemisphere
    # Avoid "windup" phenomenon caused by 4pi periodicity
    if(q'*q_ref < 0)
        q .= -q
    end
    
    delta_phi = qtorp(L(q_ref)'*q)
    
    return maximum(abs, [x[1:3] - x_ref[1:3]; delta_phi; x[8:13] - x_ref[8:13]])
end

"""
TODO...
"""
function find_hover_conditions(model, height)
    @test height >= model.prop_min_h
    
    local r = [0.0; 0; max(height, model.prop_min_h)]
    local q = [1.0; 0; 0; 0]
    local v = zeros(3)
    local ω = zeros(3)
    x_hover = [r; q; v; ω];

    local weight = model.m * model. g
    
    local kge = model.kt * ground_effect(height, model.R, model.ρ, model.prop_min_h)
    
    u_hover = (weight/(4*kge))*ones(4)
    
    return x_hover, u_hover
end

"""
    TODO...
"""
function reduce_x_state(x_full)
    return [x_full[1:3]; qtorp(x_full[4:7]); x_full[8:13]]
end