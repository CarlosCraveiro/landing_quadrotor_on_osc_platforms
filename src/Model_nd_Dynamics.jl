import Pkg
Pkg.activate(@__DIR__)

using LinearAlgebra
using Test

include("Quaternion.jl")

"""
    Model

Holds the physical parameters of the quadrotor model.

# Fields
- `g::Float64`: Gravitational acceleration (m/s²).
- `m::Float64`: Quadrotor mass (kg).
- `ℓ::Float64`: Distance from the quadrotor center to each propeller (m).
- `J::Matrix{Float64}`: 3×3 inertia matrix (kg·m²).
- `R::Float64`: Propeller radius (m).
- `prop_min_h::Float64`: Minimum height above ground where ground effect is considered (m).
- `ρ::Float64`: [Ground effect](https://doi.org/10.1109/ChiCC.2015.7260521) correction factor.
- `umin::Vector{Float64}`: Minimum thrust for each of the 4 motors (N).
- `umax::Vector{Float64}`: Maximum thrust for each of the 4 motors (N).
- `kt::Float64`: Propeller thrust coefficient (N/rad²·s⁻²).
- `km::Float64`: Propeller moment coefficient (N·m/rad²·s⁻²).
- `Nx::Int32`: Size of the full state vector.
- `Nu::Int32`: Size of the control input vector.
- `K_aero::Matrix{Float64}`: Aerodynamic drag matrix, based on
  [ETH Zurich reference](https://www.research-collection.ethz.ch/entities/publication/9973b834-69c3-45a0-bb2c-240da4314818).
"""
mutable struct Model
    g::Float64 # gravity
    m::Float64 # mass
    ℓ::Float64 # inter-propeller distance
    J::Matrix{Float64} # inertia momment matrix
    R::Float64 # propeller radius
    prop_min_h::Float64 # TODO
    ρ::Float64 # GE correction factor (https://doi.org/10.1109/ChiCC.2015.7260521)
    umin::Vector{Float64} # Thrust inferior limit
    umax::Vector{Float64} # Thrust superior limit

    kt::Float64 # Thrust Coefficient
    km::Float64 # Moment Coefficient

    Nx::Int32 # Full state vector size
    Nu::Int32 # Full control dimension

    K_aero::Matrix{Float64} # K aero drag matrix
    # A drag model extracted from (https://www.research-collection.ethz.ch/entities/publication/9973b834-69c3-45a0-bb2c-240da4314818)
end

"""
    ground_effect(height, prop_radius::Float64, adjust_factor::Float64, height_saturation::Float64)

Calculates the ground effect factor on the thrust generated by the propellers. Extracted from [here](https://doi.org/10.1109/ChiCC.2015.7260521)

This function models the increase in thrust efficiency when the quadrotor is close to the ground.

# Arguments
- `height`: Current height of the quadrotor above the ground (m).
- `prop_radius::Float64`: Radius of the propeller (m).
- `adjust_factor::Float64`: Ground effect correction factor (ρ from the Model struct).
- `height_saturation::Float64`: Minimum height below which ground effect is saturated (prop_min_h from the Model struct).

# Returns
- `Float64`: The ground effect amplification factor (>= 1).
"""
function ground_effect(
        height, 
        prop_radius::Float64, 
        adjust_factor::Float64, 
        height_saturation::Float64
    )
    saturated_height = max(height, height_saturation)
    return (1/(1 - adjust_factor*(prop_radius/(4*saturated_height))^2))
end

"""
    quad_dynamics(model::Model, x, u, plat_h::Float64, wind_dir, wind_speed::Float64) -> Vector{Float64}

Computes the nonlinear dynamics of the quadrotor, returning the time derivative of its
state vector. The model includes gravity, ground effect, wind disturbance, and aerodynamic drag.

# Arguments
- `model`: Quadrotor physical parameters (`Model` struct).
- `x`: Current state vector `[r; q; v; ω]`:
    - `r`: Position in inertial frame (3×1, m).
    - `q`: Unit quaternion representing orientation (4×1).
    - `v`: Linear velocity in body frame (3×1, m/s).
    - `ω`: Angular velocity in body frame (3×1, rad/s).
- `u`: Control input vector of motor thrusts (4×1, N).
- `plat_h`: Platform or ground height used in ground effect calculations (m).
- `wind_dir`: Unit vector indicating wind direction in world frame (3×1).
- `wind_speed`: Wind speed magnitude (m/s).

# Returns
- `Vector{Float64}`: State derivative `dx = [dr; dq; dv; dω]`.
"""
function quad_dynamics(
        model::Model,
        x,
        u,
        plat_h::Float64,
        wind_dir,          # 3×1 unit vector, world frame
        wind_speed::Float64
    )
    r = x[1:3]
    q = x[4:7] / norm(x[4:7]) # Ensure q is a unit quaternion
    v = x[8:10] # Defined at the body frame
    ω = x[11:13] # Angular velocity
    
    Q = qtoQ(q) # Compute the Rotation Matrix

    m = model.m
    g = model.g
    J = model.J
    kt = model.kt
    km = model.km
    ℓ = model.ℓ

    quatm = QuaternionMatrices()
    H = quatm.H
    
    dr = Q * v
    dq = 0.5 * L(q)*H*ω

    kge = ground_effect(x[2] - plat_h, model.R, model.ρ, model.prop_min_h)

    # Wind effect and Translational drag
    v_rel = v - Q' * (wind_speed .* wind_dir)    # body-frame relative airspeed
    θdot = sqrt.(u ./ kt)             # per-rotor angular speeds from thrusts
    θΣ = sum(θdot)                               # sum of rotor speeds (rad/s)
    F_aero_b = - (model.K_aero * (θΣ .* v_rel))  # aerodynamic drag (body frame)

    dv = Q'*[0; 0; -g] + (1/m)*[zeros(2,4); kge*ones(1,4)]*u + (1/m)*F_aero_b - hat(ω)*v
    dω = J\(-hat(ω)*J*ω + [0 ℓ 0 -ℓ; -ℓ 0 ℓ 0; km/kt -km/kt km/kt -km/kt]*u)
    
    return [dr; dq; dv; dω]
end

"""
    infinity_norm_of_difference(x::Vector{Float64}, x_ref::Vector{Float64})

Calculates the infinity norm of the difference between two state vectors, handling quaternion normalization.

This function computes the maximum absolute difference between corresponding elements of two state vectors. It also ensures that the quaternions in both state vectors are in the same hemisphere to avoid issues with the double cover of SO(3).

OBS: Currently not being used!

# Arguments
- `x::Vector{Float64}`: The first state vector.
- `x_ref::Vector{Float64}`: The reference state vector. Both vectors are assumed to be in the format `[r; q; v; ω]`.

# Returns
- `Float64`: The infinity norm of the difference between the two state vectors.
"""
function infinity_norm_of_difference(x::Vector{Float64}, x_ref::Vector{Float64})
    q = x[4:7]
    q_ref = x_ref[4:7]
    
    # Ensure that q and q_ref are in the same hemisphere
    # Avoid "windup" phenomenon caused by 4pi periodicity
    if(q'*q_ref < 0)
        q .= -q
    end
    
    delta_phi = qtorp(L(q_ref)'*q)
    
    return maximum(abs, [x[1:3] - x_ref[1:3]; delta_phi; x[8:13] - x_ref[8:13]])
end

"""
    find_hover_conditions(model::Model, height::Float64)

Calculates the hover state and the required control input (thrust) for a given height.

This function determines the state vector (position, orientation, velocities) and the collective thrust needed for the quadrotor to maintain a stable hover at a specified height.

# Arguments
- `model::Model`: The `Model` struct containing the quadrotor's physical parameters.
- `height::Float64`: The desired hover height above the ground (m).

# Returns
- `Tuple{Vector{Float64}, Vector{Float64}}`: A tuple containing:
    - `x_hover::Vector{Float64}`: The hover state vector `[r; q; v; ω]`.
    - `u_hover::Vector{Float64}`: The control input vector (collective thrust for each motor) required for hover.
"""
function find_hover_conditions(model::Model, height::Float64)
    @test height >= model.prop_min_h
    
    local r = [0.0; 0; max(height, model.prop_min_h)]
    local q = [1.0; 0; 0; 0]
    local v = zeros(3)
    local ω = zeros(3)
    x_hover = [r; q; v; ω];

    local weight = model.m * model. g
    
    local kge = ground_effect(height, model.R, model.ρ, model.prop_min_h)
    
    u_hover = (weight/(4))*ones(4)
    
    return x_hover, u_hover
end

"""
    reduce_x_state(x_full::Vector{Float64})

Reduces the full state vector by replacing the quaternion with its Rodriguez parameters.

This function takes the full 13-element state vector and returns a reduced 12-element state vector where the 4-element quaternion is replaced by the 3-element Rodriguez parameter representation of the orientation.

# Arguments
- `x_full::Vector{Float64}`: The full state vector `[r; q; v; ω]`.

# Returns
- `Vector{Float64}`: The reduced state vector `[r; q_rp; v; ω]`, where `q_rp` are the Rodriguez parameters.
"""
function reduce_x_state(x_full::Vector{Float64})
    return [x_full[1:3]; qtorp(x_full[4:7]); x_full[8:13]]
end